iOSアプリケーションの開発では基本的にSwiftという言語を使うのが一般的になっています。SwiftはWWDC2014で発表されたアップル謹製のプログラミング言語です。

従来のiOSアプリケーション開発で使われていたObjective-CやC言語と共存、それらの資産を利用できるように意図されて設計が行われています。Swiftは様々なパラダイムで構成されているいわゆるマルチパラダイムプログラミング言語の一つです。

現在はGoogleでSwift for TensorFlowなどのプロジェクトに取り組んでいるChirs lattnerによって開発が進められていて、現在はオープンソースとして開発されています。SwiftはオープンソースでUIを構築する一部のフレームワークなど内部実装が非公開なものもあります。

Swift.orgではこれまでの議論や今後実装される機能について議論が重ねられていて英語に抵抗がなければその内容を見ることができます。

今日はそんなSwiftについてSwiftを知らない人向けに話をします。安全性を重視しながらコードの記述にストレスを感じないように様々な言語仕様が設計されています。SwiftはAppleのデバイス上で動作するアプリケーションの開発ぐらいにしか使われていないという現実を脇に置けば誰にでも進められるプログラミング言語の一つだと個人的には考えています。

Swiftは静的型付けでかつ型推論があります。静的型付けだけでは記述の際のストレスが生じてしまいます。他のメジャーな静的型付け言語と同じようにSwiftは型推論により方の記述が最小限で済むようになっています。

null安全について

以前Swiftのnull安全について書かれた記事が少し話題になったことがありました。

記事に対して書かれた意見をいくつかピックアップしてnull安全についてもう少し見ていきたいと思います。
寄せられた意見の一つにnull安全があってもちゃんとやるのを忘れてしまうのでは。という意見がありました。
Swiftでは忘れません。やらないとコンパイルが通らないからです。フェッチしてきたコードがコンパイルできなければコミットした人がミスをしていることが確定します。

また、それらのミスはコンパイラが事前に警告を出し、場合によっては自動で矯正するオプションが用意されてることもあります。

他に記憶に残っているのはnullになりうるポインタはよく使う。その変数がnullになる場所、ならない場所を考慮できるしassertionによってバグもすぐに発見可能。null安全があっても便利には感じないという意見です

そういうスタイルは従来の言語で正しいプログラミングのスタイルだと思います。ただ、万が一のミスを考慮から外すことができません。万が一のミスを産まないためにコンパイラの補助があると助かります。

null安全はnullableだけがメリットではありません。多くの場合nullableな値のハンドリングを正しく行う話しがされますが、便利なのはそれと対になるnonnullな値の便利さです。

実際にアプリケーションのコードを書くときnullにならないプロパティを持つちょっとしたデータ型のような簡単なクラスの話がよく出てきます。

アプリケーションの規模が大きくなるにつれてそういうクラスまたは構造体の数は増えてきます。しかも様々な所で顔を出します。

そういう時にプロパティがnullableかどうかコンパイラが見てくれているのでnonnullと思ってコードを書いていけます。コンパイラに怒られたらそれをnullableとして扱えば良いです。

また、null安全は特にテストコードと対立するものではありません。ただテストコードを書く前にnullに関するバグを発見してくれます。自動で完璧に網羅されたテストコードを書いてくれるようなイメージです。

人間はミスをします。人間はなにをやるかわかりません。コンパイラはミスをしません。コンパイラは何をやるのかそれを知ることができます。人間はもっと難しい問題に取り組むべきです。機会が得意なことは機械にやってもらうと気持ち良いですよというのがnull安全を持つSwiftを気に入っている理由です。

多くの場合技術はトレードオフがあります。メリットとデメリットが同時にもたらされて場合によってはデメリットの方が高く見積もられます。

Swiftのnull安全にデメリットは存在しません。null安全性を担保しながら生産性を低下させない言語仕様です。トレードオフ論は一般的には妥当だと思います。しかしそもそも間違っているものを正すことにデメリットは存在しないということです。

ここで指している間違っているもの、というのは型Tの変数にnullが代入できるという言語設計のことです。

Tにnullが代入できることがなぜいけないか。それはそもそもnullはTではないからです。TであるというのはTとして使えるということを意味します。nullはTとしては使えません。Tとしての値も持たずTとして振る舞うこともできません。Tじゃないんだから振る舞いを定義できないのは当然のことです。

Tにnullが代入できるとT型の式を評価することに常にnullである可能性を排除できないです。

Null参照を発明したアントニー・ホーア氏はNull参照を発明したことについて謝罪しています。
>> それは10億ドルにも相当する私の誤りだ。null参照を発明したのは1965年のことだった。当時、私はオブジェクト指向言語 (ALGOL W) における参照のための包括的型システムを設計していた。目標は、コンパイラでの自動チェックで全ての参照が完全に安全であることを保証することだった。しかし、私は単にそれが容易だというだけで、無効な参照を含める誘惑に抵抗できなかった。これは、後に数え切れない過ち、脆弱性、システムクラッシュを引き起こし、過去40年間で10億ドル相当の苦痛と損害を引き起こしたとみられる。

Tと書いているのにT型にアクセスできない場合ができてしまっています。これは重大な問題です。null安全な言語では有効無効がありえる参照と常に有効なのが保証されている参照を完全に区別します。

また、有効だったり無効だったりする参照が一つのポインタで表現できるのには変わりないのでメモリ効率が悪くなることもありません。

メモリ上のサイズや表現方法は同一でコンパイル時に型として区別されるので実行パフォーマンス上のロスは存在しません。

SILを読みます

今回はLLVM Developer's MeetingでSwift CoreチームのメンバーのJoe Groff と Swiftの生みの親のChris Lattnerが行ったSwiftコンパイラについての発表の中で話題に出ていたbox-to-stack optimizationの話をします。

box-to-stackはGuaranteed OptimizationのMemory promotionにあたります。
メモリ領域はテキスト領域、データ領域、BSS領域、スタック領域に分かれていますが
今回扱うのはヒープ領域とスタック領域です
ヒープ領域は動的なメモリ確保に使用され、スタック領域は関数の引数やローカル変数にしようされます。

ヒープ領域は任意のサイズのデータを任意の順序で確保・開放する方式でメモリ管理をしているのでぜんｔ内のメモリ上のどこで何が確保されているのかを管理する必要があります。

"任意"なのでここではスコープが明確でない場合や実行時にしかサイズが確定しない場合や必要なサイズが大きいデータを置けます。

スタックはLast In First outというデータ格納方式で管理されています。PushとPopという操作で後入れ先出しの構造でデータを保持しています。

Swiftでは関数呼び出しや予めスコープが決まっているデータをスタックに置いて、スコープが終わったらスタックのデータが開放されます。
非常に高速ですがヒープ領域で行いたいことには向いていません。

別の言語を一つ紹介します。最近クラスメソッドではRustの社内勉強会が定期的に行われています。Rustではスタックの高速性を活かすために、ローカル変数などの基本的なあたいはスタックに起きます。メモリを異なる関数間でやり取りしたい場合やいっかいの　関数実行より長く保持する場合はBox<T>型を使ってメモリをヒープ上に確保します。そのドレスを持ったポインタをスタックに確保します。

ヒープに確保することで関数のスコープを気にせずにあたいを保持することができます。代わりにスタックに同時に保持していあるポインタが開放された時、明示的にヒープからも開放する必要があります。

今回は他の言語でもある変数を定義する機能と定数を定義する機能についてみていきます。これはSILの入門として非常により組みやすい話で、プログラミングの経験があれば完全に理解できるコードから出発するのでCSのバックグラウンド等もほとんど必要ないです。この話について詳細に書かれた記事もあるので興味のある方はお手すきのときにでも検索されてみてください。

定数を定義する時、Swiftではletというキーワードを使い、変数を定義する時にはvarを使います。変数は何度でも代入でき、定数は逆に代入は一度切りです。

swiftのコードは単純な文字列を返すだけの関数を定義しただけのものです。2つのファイルの差分はvarを使っている部分をもう一方のファイルではletに変更しているだけです。

SILを生成するには`swiftc`コマンドを使用します。
`swiftc -emit-silgen var.swift -o var.silgen`
-oオプションをswiftファイルの後に指定すれば別ファイルに内容を生成できます。

生成すると以下のようになります。
コメントも書かれていて人間でも読める形で書かれています。

SIL.rstを見る

alloc_box
レファレンスカウンター方式@boxがヒープに確保される
ボックスの初期化時に参照カウントが1になり、参照カウントが0になると開放されます。
返り値はBoxオブジェクトの参照先です

project_boxという命令を使うとBoxオブジェクトが保持している値のアドレスを取得できる


alloc_stack

alloc_stackは、値をスタック に確保します。こちらはリファレンスカウンタ方式ではありません。メソッドのスコープ内で解放する必要があります。
返り値はそのアドレスです
alloc_stackは最後dealloc_stackを呼ぶ必要があります

このことからメモリ領域に確保する必要がない変数。関数が終了した時にスコープ内の変数も開放してしまって問題ない場合にヒープ領域ではなくスタック領域を使おうとする最適化を行っていると考えられます。
それでは関数が終了してもスコープ内の変数を開放せずに確保しておかないといけない場合とはどういう時でしょうか。
Swiftではクロージャに対して@escapingというattributeを付与できます。このattributeを付与するとクロージャを非同期実行できます。この場合は関数内の各命令が終わっても値を開放するわけにはいきません。実際に@escapingを付与したクロージャ内で定義した変数は最適化後もスタック領域を使用するように変更されません。


findUnexpectedBoxUseについて見ていきます
基本的にコメントに記載されている通りです

alloc_boxによるレファレンスカウントに関する命令です。
copy_valueされたりmark_uninitializedなものは再帰的に確認します。
partial_applyはエスケープするクロージャを生成できます。したがってpartial_apply命令が使われていてもエスケープしない場合はメモリプロモーションが可能です
